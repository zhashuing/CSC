# 进程与线程
## 进程
#### 进程模型
操作系统种最核心的概念就是进程，进程就是对正在运行的程序的一种抽象，操作系统的其他概念就是围绕进程展开，因此深入了解和学习进程是十分有必要的。概括的讲，一个进程就是一个正在执行的程序的实例，包括程序计数器，寄存器，和变量的当前值。在这里我们假设我们的计算机只有一个CPU(虽然现在多核处理器的计算机大行其道)，这有助于我们简化对问题的分析。在多道程序设计系统中，CPU通常是在多个程序之间不停切换，每个程序执行相当短的时间，一般在几十到几百毫秒，这就给我们用户造成了多道程序并行执行的伪并行假象(现在的CPU已经在硬件上支持并行了)。进程和程序之间的关系十分微妙，一个进程是某一种类型的一个活动，它包含程序、输入、输出和状态。进程就好比是程序的一个实例，同一个程序执行两次会得到两个进程。
#### 进程的创建
操作系统需要由方式创建一个进程。对于一些简单的只执行一个程序系统(如微波炉中的控制器)，课能在系统启动时就已经创建好了需要执行的进程，因为这些进程的内容相对固定，因此相对简单。对于更通用的系统，需要有某在方法在系统需要时按照需要创建进程。如下是四种时间会导致系统创建进程:<br>
①系统初始化。<br>
②正在运行的进程调用了创建进程的系统调用(System Call)。<br>
③用户请求创建一个进程。<br>
④一个批处理系统的初始化。<br>
启动操作系统时通常会创建很多进程，其中很多进程是前台进程，和有很多后台进程，这些进程与特定的用户没有关系，属于操作系统，这些后天进程具有某些功能，例如Web进程会处理用户的请求，邮箱进程会检查是否有邮件到达。这些守候在后台服务的进程通常被称之为守护进程(daemon)。在UNIX及其衍生系统中可以通过ps命令查看系统有哪些进程，Windows系统可以查看任务管理器。除了在系统初始化时创建进程，正在执行的进程通常也能够创建进程来帮助其完成任务，对于Windows的图形界面，通过双击就能启动应用，这是一种用户主动创建进程的方式。对于批处理系统，当提交一个批处理作业时，批处理操作系统就会创建一个进程来处理批处理作业。在类UNIX系统中，创建进程的系统调用只用fork。在调用fork后，这两个进程拥有相同的内存映像，同样的环境变量，和同样的打开的文件。在创建了进程后，父子进程拥有不同的地址空间(内存地址集合)。对于父子进程，不可变内存区域可以共享，可变内存区域不可共享。
#### 进程的终止
进程由创建就有终止，进程终止可能是自愿的，也可能是被迫的，以下几种情况会导致进程:<br>
①程序执行完成自动退出(自愿的)<br>
②程序执行遇到错误退出(自愿的)<br>
③严重错误(非自愿)<br>
④被其他进程杀死(非自愿)
#### 进程的层次结构
在类UNIX操作系统中，父进程和子进程是以一种树的关系维系在一起，真个系统是以一颗init进程为根的树。相反在Windows系统中进程间没有这种关系，所有进程的地位平等。
#### 进程的状态
进程的状态:创建，就绪态，运行态，阻塞态，终止。进程在就绪、阻塞、运行这三种状态之间进行轮转。轮转关系如下:<br>
![进程间的状态转换](../../img/进程间的状态转换.png)
<br>转化1:当正在运行的程序需要执行I/O操作(等待用户输入，等待打印机)时，会发生转化1，由运行态转到阻塞态，CPU会被调度程序调度其他的进程继续执行，而被阻塞的进程则等待I/O事件发生。
<br>转化2:当正在执行的进程使用完了CPU分配的时间片，就会发生转换2，由运行态转化的就绪态，通常会把进程保存在操作系统内部维护的就绪队列，以便下次被调用程序再次调用使用CPU执行程序。
<br>转化3:当新创建的进程或者刚刚由运行态转到就绪态的进程再次被调度程序(Scheduler)调度获得CPU使用权就会发生转换1。
<br>转化4:当等待I/O时间的进程的I/O实践发生了，这是他不能直接执行，需要先转入到就绪态，等待在后续被Scheduler调度从而再次获得执行。<br>
转化2和转化3会使用到调度程序，用户可能都感受不到它的存在，调度程序需要决定应当那个程序运行，何时运行，运行多长时间(这在后面的调度算法时会讲到)。
#### 进程的实现
为了实现进程模型，操作系统需要维护一张表格，既进程表(process table),每个进程占用进程表中的一项，该表项包含进程的一些重要信息，例如程序计数器，堆栈指针，内存分配状态，打开的文件状态，账号信息和调度信息(优先级等)，以及进程又运行态转化到就绪态和阻塞态需要保存的信息，以便进程再次执行的时候能够接着上一次执行的位置执行，就好像进程从没有中断过一样。
## 线程
#### 为什么引入线程
为什么在已经有了进程的基础之上还需要引入线程，有很多理由说明线程是非常有必要的。系统需线程(多线程)的原因：如果某个进程中有多个活动，多个活动之间没有相互的关联，对于传统的单线程进程，一些活动的执行可能会被其他活动因为执行时间过长或者发生I/O而阻塞，因此如果引入线程(多线程)将极大的提升系统的性能，同时程序的设计模型也变得什么清晰简单。同时，线程相对于进程是更加轻量级的，线程的创建、销毁、调度都比进程完成这些操作需要更小的代价，创建一个线程比创建一个进程快上10~100倍，因此对于大量线程需要动态创建时这一特性将十分有益。在性能上，如果多个线程都属于CPU密集型，那么在性能上不会获得太大的提升，但是对于多道程序设计中，同时存在CPU密集型进程和I/O密集型程序，多线程运行这些程序之间重叠执行，在性能上将获得很大的提升。相信Web服务器的例子用来说明为什么多线程是有益的并且也是有必要的会非常具有说服力。在高并发应用中，面对大量同时间到来的并发请求，需要多个线程之间进行相互协作完成用于的请求，并且还要保证用户请求的正确性和响应速度。典型的，Web应用中会有专门的线程(分派线程，dispatcher)负责从网络中读取用户请求，如果有新的请求到来，它不会自己处理请求而是将请求转发给工作线程(worker thread)来处理用户的具体请求，例如结算购物车等，这里体现了多个线程间分工明确又相互协作来完成工作，多线程能够很好的胜任这份工作，这一切看似也理所因当。但试想一下如果没有线程而是使用进程来处理呢？传统的进程模型就相当于只有一个线程的进程，那么一个线程将既要完成分发程序的工作(从网络中读取新的请求)，又要进行实际的业务逻辑处理(复杂且长时间的计算，长时间的I/O操作)，并且在处理一个请求的同时对于其他请求几乎是无法处理或者被处理时间会很长，这对于现在的应用和用户都是无法接受的(那样用户会很沮丧，因为这是一种糟糕的程序设计)。通过对比我们就可以看出多线程对与我们的程序设计是有很大的帮助的，很多复杂的程序设计也需要借助多线程来完成工作。
#### 经典的线程模型
对于进程而言，统一进程中的线程共享进程的地址空间，打开的文件，环境变量等，同一个进程的线程可以创建甚至删除一个线程，因为在进程内部线程没有类似于进程之间的地址空间空间，因此就没有保护措施来保证一个线程不被其他线程销毁。这是显然的，因为同一个进程中的线程是是用于协同完成某一任务或多个任务。与进程的状态类似，线程的状态也也有创建、就绪、运行、阻塞、终止这几种中的一个。每个线程有自己的数据结构，包括程序计数器(指示接下来要执行哪一行指令)，寄存器，堆栈、状态、调度信息等。<br>
线程相关的库函数<br>
thread_create: 创建新的线程，thread_create的参数用于新创建的线程的名字。
thread_exit: 该过程将在线程退出时执行，接着线程就消失了，不再被调度。
thread_yield: 该过程允许一个线程自动放弃CPU而让其他线程执行，不同于进程，进程可以使用时钟中断强制线程让出CPU执行权，该库过程可用于一个线程主动放弃CPU执行权来让其他线程获得执行权，也可以用于一个线程等待另一个线程执行完任务。

#### POSIX线程(Portable Operation System Interface of UNIX)

为实现可移植的线程程序，IEEE定义了线程标准，如下是一些主要的函数:

| 系统调用             | 描述                            |
| -------------------- | ------------------------------- |
| pthread_create       | 创建一个新新线程                |
| pthread_exit         | 结束调用的线程                  |
| pthread_join         | 等待一个特定的线程退出          |
| pthread_yield        | 主动释放CPU执行权让其他线程执行 |
| pthread_attr_init    | 创建并初始化一个线程的属性结构  |
| pthread_attr_destroy | 删除一个线程的属性结构          |

#### 在用户空间实现线程



#### 在内核空间实现线程
#### 混合实现
#### 线程的一些特性

## 进程与线程之间的区别与联系

